Index: mgr_s4_tracker_v1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import constants as k\r\nimport datetime\r\nimport time\r\nimport plotly.graph_objects as go\r\nfrom statistics import mean, stdev, median\r\nimport sqlite3\r\nimport json\r\n\r\nsat_database = \"gps_satellites.db\"\r\nnullvalue = \"none\"\r\noptimum_altitude = 25\r\n\r\n\r\ndef database_parse(hourduration):\r\n    starttime = int(time.time()) - (60 * 60 * hourduration)\r\n    print(\"Querying database...\")\r\n    gpsdb = sqlite3.connect(sat_database)\r\n    db = gpsdb.cursor()\r\n\r\n    result = db.execute('select posixtime, alt, avg(s4) from satdata where posixtime > ? and alt > ? group by posixtime order by posixtime asc', [starttime, optimum_altitude])\r\n    returnlist = []\r\n    for item in result:\r\n        dp = (item[0], item[1], item[2])\r\n        returnlist.append(dp)\r\n    print(\"current query \" + str(len(returnlist)) + \" records long\")\r\n    gpsdb.commit()\r\n    db.close()\r\n    return returnlist\r\n\r\n\r\ndef posix2utc(posixtime, timeformat):\r\n    # '%Y-%m-%d %H:%M'\r\n    utctime = datetime.datetime.utcfromtimestamp(int(posixtime)).strftime(timeformat)\r\n    return utctime\r\n\r\n\r\ndef indexposition(posixtime, starttime):\r\n    interval = posixtime - starttime\r\n    interval = int(interval / 60)\r\n    return interval\r\n\r\n\r\ndef plot_chart(filename, dates, aggregatedata, seriesnames):\r\n    # Colours set up for a max of ten days of data!\r\n\r\n    filename = k.dir_images + \"/\" + filename\r\n    bkcolour = \"#e0e0e0\"\r\n    gridcolour = \"#d0d0d0\"\r\n    colourdict = [\r\n        \"rgba(79,208,168,0.9)\",\r\n        \"rgba(193,166,67,0.9)\",\r\n        \"rgba(123,177,91,0.9)\",\r\n        \"rgba(192,105,186,0.9)\",\r\n        \"rgba(108,123,213,0.9)\",\r\n        \"rgba(184,85,60,0.9)\",\r\n        \"rgba(185,74,115,0.9)\",\r\n        \"rgba(81,44,123,0.9)\"\r\n    ]\r\n    sundict = [\r\n        [367, 1286],\r\n        [412, 1250],\r\n        [452, 1200],\r\n        [433, 1082],\r\n        [471, 1037],\r\n        [498, 1018],\r\n        [494, 1033],\r\n        [457, 1067],\r\n        [401, 1105],\r\n        [404, 1204],\r\n        [357, 1248],\r\n        [341, 1284]\r\n    ]\r\n    month_number = int(posix2utc(time.time(), \"%m\"))\r\n    fig = go.Figure()\r\n    fig.update_yaxes(range=[8, 26], gridcolor=gridcolour)\r\n    fig.update_xaxes(nticks=48, tickangle=45, gridcolor=gridcolour)\r\n\r\n    fig.add_vline(x=sundict[month_number][0], annotation_text=\" &#9790; \", annotation_position=\"top right\",\r\n                  line_width=2, line_color=\"blue\", annotation_font=dict(size=50, color=\"blue\"))\r\n    fig.add_vline(x=sundict[month_number][1], annotation_text=\" &#9788; \", annotation_position=\"top left\",\r\n                  line_width=2, line_color=\"orangered\", annotation_font=dict(size=50, color=\"orangered\"))\r\n\r\n    max = len(aggregatedata)\r\n    for i in range(0, max):\r\n        # all previous readings\r\n        if i < max - 3:\r\n            fig.add_scatter(x=dates, y=aggregatedata[i], mode=\"lines\", connectgaps=True,\r\n                            name=seriesnames[i], line=dict(color=colourdict[i], width=2))\r\n        # Yesterday's reading\r\n        if i == max - 2:\r\n            fig.add_scatter(x=dates, y=aggregatedata[i], mode=\"lines\", connectgaps=True,\r\n                            name=seriesnames[i], line=dict(color='rgba(255, 0, 0, 1)', width=4))\r\n        # Today's reading\r\n        if i == max - 1:\r\n            fig.add_scatter(x=dates, y=aggregatedata[i], mode=\"lines\", connectgaps=True,\r\n                            name=seriesnames[i], line=dict(color='rgba(0, 0, 0, 1)', width=4))\r\n\r\n    fig.update_layout(width=1500, height=600, title=\"S4 index (GPS Noise). http://DunedinAurora.NZ\",\r\n                      xaxis_title=\"Date/time UTC<br><sub>http://DunedinAurora.nz</sub>\",\r\n                      yaxis_title=\"S4 Index\",\r\n                      plot_bgcolor=\"#e0e0e0\")\r\n    fig.update_layout(plot_bgcolor=bkcolour, paper_bgcolor=bkcolour)\r\n    fig.write_image(file=filename, format='svg')\r\n    # fig.show()\r\n\r\n\r\ndef query_parse(queryresult):\r\n    \"\"\"\r\n    Filter the raw query result\r\n    \"\"\"\r\n    # s4_min = 0\r\n    # s4_max = 200\r\n    alt_min = 30\r\n    returnlist = []\r\n    index_s4 = 2\r\n    index_alt = 1\r\n    for item in queryresult:\r\n        # if item[index_alt] >= alt_min:\r\n            # if item[index_s4] >= s4_min:\r\n            #     if item[index_s4] <= s4_max:\r\n        dt = item[0]\r\n        dd = item[2]\r\n        d = [dt, dd]\r\n        returnlist.append(d)\r\n    return returnlist\r\n\r\n\r\ndef medianfilter(parsed_query):\r\n    # (1647323803, 20.124772)\r\n    returnlist = []\r\n    for i in range(1, len(parsed_query) - 1):\r\n        dt = parsed_query[i][0]\r\n        t = []\r\n        t.append(parsed_query[i - 1][1])\r\n        t.append(parsed_query[i][1])\r\n        t.append(parsed_query[i + 1][1])\r\n        dv = median(t)\r\n        d = [dt, dv]\r\n        returnlist.append(d)\r\n    return returnlist\r\n\r\n\r\ndef runningavg(parsed_query):\r\n    # [1647325304, 14.299302]\r\n    halfwindow = 10\r\n    returnlist = []\r\n    temp = []\r\n    for i in range(0, len(parsed_query)):\r\n        data = parsed_query[i][1]\r\n        temp.append(data)\r\n        if len(temp) > halfwindow * 2:\r\n            temp.pop(0)\r\n            dd = mean(temp)\r\n            dt = parsed_query[i - halfwindow][0]\r\n            d = [dt, dd]\r\n            returnlist.append(d)\r\n    return returnlist\r\n\r\n\r\n# Create an overlapping plot of the past x days to show re-occuring daily features in S4 data\r\ndef wrapper(query_interval):\r\n    querydata = database_parse(query_interval)\r\n    # parse out readings < 40deg in alt and 0 < s4 < 100\r\n    parsed_query = query_parse(querydata)\r\n\r\n    # Remove spikes with Median Filter\r\n    parsed_query = medianfilter(parsed_query)\r\n\r\n    # SMooth data with a running avg\r\n    parsed_query = runningavg(parsed_query)\r\n\r\n    # Slice data by UTC days and created stacked lists for plotting\r\n    null = None\r\n    aggregate_data = []\r\n    tmp = []\r\n\r\n    for j in range(0, 86400):\r\n        tmp.append(null)\r\n\r\n    for i in range(0, len(parsed_query) - 1):\r\n        t1 = parsed_query[i][0] % 86400\r\n        t2 = parsed_query[i + 1][0] % 86400\r\n        tmp[t1] = parsed_query[i][1]\r\n        if t1 - t2 > 70000:\r\n            aggregate_data.append(tmp)\r\n            tmp = []\r\n            for j in range(0, 86400):\r\n                tmp.append(null)\r\n    aggregate_data.append(tmp)\r\n\r\n    # Generate list of hours/mins for plotter\r\n    aggregate_dates = []\r\n    for i in range(0, 86400):\r\n        aggregate_dates.append(posix2utc(i, \"%H:%M\"))\r\n\r\n    # generate a list of dates for the legend\r\n    datelist = []\r\n    d0 = posix2utc(parsed_query[0][0], \"%b-%d\")\r\n    datelist.append(d0)\r\n    for item in parsed_query:\r\n        d1 = posix2utc(item[0], \"%b-%d\")\r\n        if d0 != d1:\r\n            datelist.append(d1)\r\n            d0 = d1\r\n\r\n    plot_chart(\"s4_aggregate.svg\", aggregate_dates, aggregate_data, datelist)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mgr_s4_tracker_v1.py b/mgr_s4_tracker_v1.py
--- a/mgr_s4_tracker_v1.py	(revision 9d73d1a11b05436a0a1ef06bd863402c6b9414ac)
+++ b/mgr_s4_tracker_v1.py	(date 1648517597426)
@@ -100,8 +100,8 @@
                       yaxis_title="S4 Index",
                       plot_bgcolor="#e0e0e0")
     fig.update_layout(plot_bgcolor=bkcolour, paper_bgcolor=bkcolour)
-    fig.write_image(file=filename, format='svg')
-    # fig.show()
+    # fig.write_image(file=filename, format='svg')
+    fig.show()
 
 
 def query_parse(queryresult):
